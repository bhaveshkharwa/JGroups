
Changing the key exchange in ASYM_ENCRYPT from pull to push model
=================================================================

Author: Bela Ban
Date:   Jan 2019


Problem
=======

ASYM_ENCRYPT has a shared group key (SGK) which is used by all group members to encrypt / decrypt messages.

The SGK is created by the coordinator and transferred to new members when they join. Also, if members leave and
change_key_on_leave is true (default), then the shared key needs to be changed by the coordinator and also be
installed in all members.

The transfer of the SGK from the coordinator to members is called _key exchange_. This can be done in 2 ways:

1. The coordinator encrypts the SGK with the public key of a member, which decrypts it with its private key.
   However, this is prone to man-in-the-middle attacks.
2. Via an SSL connection between member and coordinator. This is currently done via an additional protocol
   (e.g. SSL_KEY_EXCHANGE).

In both cases, a *pull mechanism* is used: the client notices (or is told) that the SGK is no longer valid, and *pulls*
it from the coordinator. Until the new SGK is installed, all messages will be discarded.

This can lead to problems, e.g. in the following scenario:
* Coordinator A installs a new view V=A,B,C,D (E left)
* V is encrypted with the new SGK that the coordinator just created
* Members B, C and D now fetch the new SGK from the coordinator
* V is received by B, C and D: those members who have the new SGK will be able to decrypt and deliver V, the others
  will discard it.
==> Unless the coordinator sends a new multicast message, V will not get delivered by some members (until STABLE kicks
    in and retransmits V), leading to a plethora of issues.


Solution
========

Instead of using a *pull* approach for key exchange, a *push* approach should be used: the transfer of the SGK needs to
be initiated by the *coordinator* rather than the joiners (on JOIN) or other members (on VIEW / MERGE-VIEW).

Ideally, the SGK is sent *with* the JOIN-RSP or VIEW message, and installed by the recipients _before_ the new view is
decrypted. This eliminates the delays in view installation associated with the pull approach. It may also simplify the
code.

The design below describes both external (SSL_KEY_EXCHANGE) and internal (SGK encrypted by recipient's public key)
approaches to key exchange.




Design
======
- View is V1={A,B,C,D}; A is the coordinator
- use_external_key_exchange: EX
- pub-map: map of addresses and their associated public keys


1: New member E joining the group
=================================

E sends a JOIN-REQ to A
-----------------------
- If EX == false:
    - ASYM_ENCRYPT adds a header with E's public key to the JOIN-REQ sent to A

A receives the JOIN-REQ from E
------------------------------
- If the header contains the public key of E:
    - Add E and its public key to pub-map
    - Multicast a PUB-KEY message containing the mapping between E and its public key


A sends the JOIN-RSP to E
-------------------------
- If EX == false:
    - ASYM_ENCRYPT gets E's public key from pub-map, encrypts the SGK with it, and adds the
      encrypted SGK to the JOIN-RSP
    - Send a PUB-KEY message to E containing all mappings between members and their public keys
- Else
    - ASYM_ENCRYPT sends a FETCH-SHARED-KEY message (before the JOIN-RSP) to E


E receives the JOIN-RSP from A
------------------------------
- If EX == false:
    - Get the encrypted SGK from the JOIN-RSP
    - Decrypt the encrypted SGK with the private key and install it
    - Pass the JOIN-RSP up (this will install the view)
- Else:
    - The SGK has already been installed as part of the prior key exchange run


E receives the FETCH-SHARED-KEY message from A
----------------------------------------------
- E asks its KEY_EXCHANGE protocol to fetch the SGK
- E *blocks* until the SGK has been retrieved and installed. This prevents the delivery of the JOIN-RSP,
  as the latter was sent after the FETCH-SHARED-KEY message. This means that the JOIN-RSP will have a valid
  SGK in place to decrypt it.


On reception of PUB-KEY:
------------------------
- Add the mappings between members and public key to pub-map


On view change
--------------
- Remove all mappings from pub-map whose members are not in the view


On a merge-view:
----------------
- TBD: multicast all mappings in pub-map?




2: Member D leaves the group and change_key_on_leave enabled
============================================================

***************************************************************************
*** Note that if change_key_on_leave is false, nothing needs to be done ***
***************************************************************************


A multicasts view V2={A,B,C}
----------------------------
- If EX:
    - ASYM_ENCRYPT multicasts a FETCH-SHARED-KEY message to all members (minus itself)
- Else
    - If members left:
        - ASYM_ENCRYPT creates a map of members (B and C), grabs their public keys from pub-map, and adds the SGK
          encrypted with the respective member's public key.
        - An INSTALL-SHARED-KEY message with the above map as payload is multicast to all members (B and C)
- The VIEW message is multicast to B and C


B and C receive the FETCH-SHARED-KEY message from A
---------------------------------------------------
- Both members ask its KEY_EXCHANGE protocol to fetch the SGK
- This *blocks* until the SGK has been retrieved and installed. This prevents the delivery of the succeeding VIEW message,
  as the latter was sent after the FETCH-SHARED-KEY message. This means that the VIEW message will have a valid
  SGK in place to decrypt it.


B and C receive an INSTALL-SHARED-KEY message from A
----------------------------------------------------
- Each member reads the map from the payload and gets the encrypted SGK associated with itself from the map
- The encrypted SGK is then decrypted with the member's private key, and the resulting SGK is installed


Members B and C receive V2
--------------------------
- Nothing needs to be done, as the SGK for the new view has already been installed



3. Cluster merge
================
- Clusters are V5={A,B,C} and V5={D,E,F}


New coord A unicasts INSTALL-MERGE-VIEW MergeView V6={A,B,C,D,E,F} to subgroup coords A and D
---------------------------------------------------------------------------------------------
- If EX:
    - ASYM_ENCRYPT on (new coordinator) A unicasts a FETCH-SHARED-KEY message to the subgroup coords A and D
        - On reception, A and D multicast the FETCH-SHARED-KEY message to their respective subgroups
- Else
    - D sends (unicast) SEND-PUB-KEY messages to each of B,C,D,E,F (see [1])
    - Wait until we have the public keys of all members of V6
    - Create a map of all members, grab their public keys from pub-map, and add the SGK encrypted with the respective
      member's public key.
    - A (unicast) INSTALL-SHARED-KEY message with the above map as payload is sent to each of the subgroup coordinators
      (A and D). On reception, A and D multicast the INSTALL_SHARED_KEY message to their subgroups
- The MERGE-VIEW message is unicast to the subgroup coord A and D
    - On reception, A and D multicast the MERGE-VIEW message.
- For ordering details see [3].


On reception of a SEND-PUB-KEY message from D
---------------------------------------------
- Send a PUB-KEY message (including the member's public key) back to D



Misc
====

[1] Why can't we use a multicast when merging?
----------------------------------------------
- When subgroup coordinators A and D multicast V6 in their respective subgroups, installation of V6 might occur at
  different wall clock times, e.g. V6 might get installed at T5 in {D,E,F}, but at T100 in {A,B,C}.
- If D multicast GET_SHARED_KEY at T50, then subgroup {A,B,C} would reject the message, because at T50, D was not (yet)
  a member of that subgroup. Unless FLUSH was configured, MergeViews are installed asynchronously in subgroups.
- Therefore *unicast messages* to all members are used to make sure the FETCH-SHARED-KEY messages are received by all
  members of a MergeView: unicast messages can be delivered to members outside the current view.


[2] ASYM_ENCRYPT must be located *below* GMS but *above* NAKACK2/UNICAST3
-------------------------------------------------------------------------
- The reason for below GMS is that ASYM_ENCRYPT has to intercept JOIN-REQ/JOIN-RSP and view installations
- The reason for above NAKACK2/UNICAST3 is that some messages need to be reliable (PUB-KEY) and others require
  ordering, e.g. the INSTALL-SHARED-KEY multicast needs to be delivered *before* the new VIEW


[3] Ordering between unicast and multicast messages on a merge
--------------------------------------------------------------
- The INSTALL-SHARED-KEY and MERGE-VIEW messages are unicast by A to {A,D}
- This means that both A and D will deliver INSTALL-SHARED-KEY *before* MERGE-VIEW as unicasts from the same
  member are ordered in send-order of A
- The delivery of unicast INSTALL-SHARED-KEY in A and D triggers a multicast INSTALL-SHARED-KEY to the respective subgroups
- The delivery of unicast MERGE-VIEW in A and D triggers a multicast MERGE-VIEW to the respective subgroups
- Because the unicast INSTALL-SHARED-KEY and MERGE-VIEW messages are delivered in order, this also guarantees the
  ordering between the multicast INSTALL-SHARED-KEY and MERGE-VIEW messages: the former will be delivered before the
  latter. This ensures that each member of all subgroups will have the new shared group key install before receicing the
  merge view, and can therefore decrypt it.
